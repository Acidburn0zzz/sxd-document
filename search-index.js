var searchIndex = {};
searchIndex["open"] = {"doc":"","items":[],"paths":[]};
searchIndex["sxd_document"] = {"doc":"","items":[[3,"PrefixedName","sxd_document","A prefixed name. This represents what is found in the string form\nof an XML document, and does not apply any namespace mapping.",null,null],[3,"QName","","A namespace-qualified name. This represents the name of an element\nor attribute *after* the prefix has been mapped to a specific\nnamespace.",null,null],[3,"Package","","The main entrypoint to an XML document",null,null],[0,"dom","","A traditional DOM tree interface for navigating and manipulating\nXML documents.",null,null],[3,"Document","sxd_document::dom","An XML document",null,null],[3,"Root","","The logical ancestor of every other node type",null,null],[3,"Namespace","","A mapping from a prefix to a URI",null,null],[3,"Element","","Elements are the workhorse of a document and may contain any type of\nnode, except for the Root node",null,null],[3,"Attribute","","Metadata about the current element",null,null],[3,"Text","","Textual data",null,null],[3,"Comment","","Information only relevant to humans",null,null],[3,"ProcessingInstruction","","Metadata relevant to the application, but not the XML processor or humans",null,null],[4,"ChildOfRoot","","Nodes that may occur as a child of the root node",null,null],[13,"Element","","",0,null],[13,"Comment","","",0,null],[13,"ProcessingInstruction","","",0,null],[4,"ChildOfElement","","Nodes that may occur as a child of an element node",null,null],[13,"Element","","",1,null],[13,"Text","","",1,null],[13,"Comment","","",1,null],[13,"ProcessingInstruction","","",1,null],[4,"ParentOfChild","","Nodes that may occur as the parent of a child node",null,null],[13,"Root","","",2,null],[13,"Element","","",2,null],[11,"clone","","",3,null],[11,"root","","",3,null],[11,"create_element","","",3,null],[11,"create_text","","",3,null],[11,"create_comment","","",3,null],[11,"create_processing_instruction","","",3,null],[11,"eq","","",3,null],[11,"fmt","","",3,null],[11,"clone","","",4,null],[11,"document","","",4,null],[11,"eq","","",4,null],[11,"hash","","",4,null],[11,"append_child","","",4,null],[11,"children","","",4,null],[11,"fmt","","",4,null],[11,"prefix","","",5,null],[11,"uri","","",5,null],[11,"clone","","",6,null],[11,"document","","",6,null],[11,"eq","","",6,null],[11,"hash","","",6,null],[11,"name","","",6,null],[11,"set_name","","",6,null],[11,"set_default_namespace_uri","","",6,null],[11,"default_namespace_uri","","",6,null],[11,"recursive_default_namespace_uri","","",6,null],[11,"register_prefix","","Map a prefix to a namespace URI. Any existing prefix on this\nelement will be replaced.",6,null],[11,"namespace_uri_for_prefix","","Recursively resolve the prefix to a namespace URI.",6,null],[11,"prefix_for_namespace_uri","","Recursively find a prefix for the namespace URI. Since\nmultiple prefixes may map to the same URI, `preferred` can be\nprovided to select a specific prefix, if it is valid.",6,null],[11,"namespaces_in_scope","","Retrieve all namespaces that are in scope, recursively walking\nup the document tree.",6,null],[11,"preferred_prefix","","",6,null],[11,"set_preferred_prefix","","",6,null],[11,"parent","","",6,null],[11,"append_child","","",6,null],[11,"children","","",6,null],[11,"preceding_siblings","","",6,null],[11,"following_siblings","","",6,null],[11,"attribute","","",6,null],[11,"attributes","","",6,null],[11,"set_attribute_value","","",6,null],[11,"attribute_value","","",6,null],[11,"fmt","","",6,null],[11,"clone","","",7,null],[11,"document","","",7,null],[11,"eq","","",7,null],[11,"hash","","",7,null],[11,"name","","",7,null],[11,"value","","",7,null],[11,"preferred_prefix","","",7,null],[11,"set_preferred_prefix","","",7,null],[11,"parent","","",7,null],[11,"fmt","","",7,null],[11,"clone","","",8,null],[11,"document","","",8,null],[11,"eq","","",8,null],[11,"hash","","",8,null],[11,"text","","",8,null],[11,"set_text","","",8,null],[11,"parent","","",8,null],[11,"preceding_siblings","","",8,null],[11,"following_siblings","","",8,null],[11,"fmt","","",8,null],[11,"clone","","",9,null],[11,"document","","",9,null],[11,"eq","","",9,null],[11,"hash","","",9,null],[11,"text","","",9,null],[11,"set_text","","",9,null],[11,"parent","","",9,null],[11,"preceding_siblings","","",9,null],[11,"following_siblings","","",9,null],[11,"fmt","","",9,null],[11,"clone","","",10,null],[11,"document","","",10,null],[11,"eq","","",10,null],[11,"hash","","",10,null],[11,"target","","",10,null],[11,"value","","",10,null],[11,"set_target","","",10,null],[11,"set_value","","",10,null],[11,"parent","","",10,null],[11,"preceding_siblings","","",10,null],[11,"following_siblings","","",10,null],[11,"fmt","","",10,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"element","","",0,null],[11,"comment","","",0,null],[11,"processing_instruction","","",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"element","","",1,null],[11,"text","","",1,null],[11,"comment","","",1,null],[11,"processing_instruction","","",1,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"root","","",2,null],[11,"element","","",2,null],[11,"from","","",0,{"inputs":[{"name":"element"}],"output":{"name":"childofroot"}}],[11,"from","","",0,{"inputs":[{"name":"comment"}],"output":{"name":"childofroot"}}],[11,"from","","",0,{"inputs":[{"name":"processinginstruction"}],"output":{"name":"childofroot"}}],[11,"from","","",1,{"inputs":[{"name":"element"}],"output":{"name":"childofelement"}}],[11,"from","","",1,{"inputs":[{"name":"text"}],"output":{"name":"childofelement"}}],[11,"from","","",1,{"inputs":[{"name":"comment"}],"output":{"name":"childofelement"}}],[11,"from","","",1,{"inputs":[{"name":"processinginstruction"}],"output":{"name":"childofelement"}}],[11,"from","","",1,{"inputs":[{"name":"childofroot"}],"output":{"name":"childofelement"}}],[0,"parser","sxd_document","Converts XML strings into a DOM structure",null,null],[4,"Error","sxd_document::parser","",null,null],[13,"Expected","","",11,null],[13,"ExpectedAttribute","","",11,null],[13,"ExpectedAttributeValue","","",11,null],[13,"ExpectedCData","","",11,null],[13,"ExpectedCharacterData","","",11,null],[13,"ExpectedComment","","",11,null],[13,"ExpectedCommentBody","","",11,null],[13,"ExpectedElement","","",11,null],[13,"ExpectedElementName","","",11,null],[13,"ExpectedElementEnd","","",11,null],[13,"ExpectedElementSelfClosed","","",11,null],[13,"ExpectedProcessingInstruction","","",11,null],[13,"ExpectedProcessingInstructionTarget","","",11,null],[13,"ExpectedProcessingInstructionValue","","",11,null],[13,"ExpectedVersionNumber","","",11,null],[13,"ExpectedEncoding","","",11,null],[13,"ExpectedYesNo","","",11,null],[13,"ExpectedWhitespace","","",11,null],[13,"ExpectedClosingQuote","","",11,null],[13,"ExpectedOpeningQuote","","",11,null],[13,"ExpectedDecimalReferenceValue","","",11,null],[13,"ExpectedHexReferenceValue","","",11,null],[13,"ExpectedNamedReferenceValue","","",11,null],[13,"ExpectedDecimalReference","","",11,null],[13,"ExpectedHexReference","","",11,null],[13,"ExpectedNamedReference","","",11,null],[13,"InvalidProcessingInstructionTarget","","",11,null],[13,"MismatchedElementEndName","","",11,null],[13,"InvalidDecimalReference","","",11,null],[13,"InvalidHexReference","","",11,null],[13,"UnknownNamedReference","","",11,null],[13,"DuplicateAttribute","","",11,null],[13,"RedefinedNamespace","","",11,null],[13,"RedefinedDefaultNamespace","","",11,null],[13,"EmptyNamespace","","",11,null],[13,"UnknownNamespacePrefix","","",11,null],[5,"parse","","Parses a string into a DOM. On failure, the location of the\nparsing failure and all possible failures will be returned.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[8,"XmlParseExt","","Common reusable XML parsing methods",null,null],[10,"consume_space","","Parse XML whitespace",12,null],[10,"consume_decimal_chars","","Parse XML decimal characters",12,null],[10,"consume_ncname","","Parse an XML [NCName](http://www.w3.org/TR/REC-xml-names/#NT-NCName)",12,null],[10,"consume_prefixed_name","","Parse an XML [prefixed name](http://www.w3.org/TR/REC-xml-names/#NT-QName)",12,null],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"partial_cmp","","",11,null],[11,"lt","","",11,null],[11,"le","","",11,null],[11,"gt","","",11,null],[11,"ge","","",11,null],[11,"cmp","","",11,null],[11,"recoverable","","",11,null],[0,"writer","sxd_document","Formats a DOM structure to a Write",null,null],[5,"format_document","sxd_document::writer","Formats a document into a Write",null,{"inputs":[{"name":"document"},{"name":"w"}],"output":{"name":"result"}}],[8,"XmlChar","sxd_document","Predicates used when parsing an characters in an XML document.",null,null],[10,"is_name_start_char","","Is this a [NameStartChar](http://www.w3.org/TR/xml/#NT-NameStartChar)?",13,null],[10,"is_name_char","","Is this a [NameChar](http://www.w3.org/TR/xml/#NT-NameChar)?",13,null],[10,"is_ncname_start_char","","Does this start a [NCName](http://www.w3.org/TR/REC-xml-names/#NT-NCName)?",13,null],[10,"is_ncname_char","","Is this a component of a [NCName](http://www.w3.org/TR/REC-xml-names/#NT-NCName)?",13,null],[10,"is_space_char","","Is this an [XML space](http://www.w3.org/TR/xml/#NT-S)?",13,null],[10,"is_decimal_char","","",13,null],[10,"is_hex_char","","",13,null],[10,"is_encoding_start_char","","",13,null],[10,"is_encoding_rest_char","","",13,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"partial_cmp","","",14,null],[11,"lt","","",14,null],[11,"le","","",14,null],[11,"gt","","",14,null],[11,"ge","","",14,null],[11,"cmp","","",14,null],[11,"new","","Create a `PrefixedName` without a prefix",14,{"inputs":[{"name":"str"}],"output":{"name":"prefixedname"}}],[11,"with_prefix","","Create a `PrefixedName` without an optional prefix",14,{"inputs":[{"name":"option"},{"name":"str"}],"output":{"name":"prefixedname"}}],[11,"prefix","","",14,null],[11,"local_part","","",14,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"new","","Create a `QName` without a namespace",15,{"inputs":[{"name":"str"}],"output":{"name":"qname"}}],[11,"with_namespace_uri","","Create a `QName` with an optional namespace",15,{"inputs":[{"name":"option"},{"name":"str"}],"output":{"name":"qname"}}],[11,"namespace_uri","","",15,null],[11,"local_part","","",15,null],[11,"from","","",15,null],[11,"from","","",15,{"inputs":[{"name":"str"}],"output":{"name":"qname"}}],[11,"new","","",16,{"inputs":[],"output":{"name":"package"}}],[11,"as_document","","",16,null],[11,"eq","","",16,null],[11,"fmt","","",16,null]],"paths":[[4,"ChildOfRoot"],[4,"ChildOfElement"],[4,"ParentOfChild"],[3,"Document"],[3,"Root"],[3,"Namespace"],[3,"Element"],[3,"Attribute"],[3,"Text"],[3,"Comment"],[3,"ProcessingInstruction"],[4,"Error"],[8,"XmlParseExt"],[8,"XmlChar"],[3,"PrefixedName"],[3,"QName"],[3,"Package"]]};
searchIndex["peresil"] = {"doc":"A simple and simplistic parsing library","items":[[3,"Progress","peresil","Tracks where the parser currently is and if it is successful.",null,null],[12,"point","","The current location.",0,null],[12,"status","","If the point indicates the location of a successful or failed parse.",0,null],[3,"ParseMaster","","The main entrypoint to parsing.",null,null],[3,"Alternate","","Follows the first successful parsing path.",null,null],[3,"StringPoint","","Tracks the location of parsing in a string, the most common case.",null,null],[12,"s","","The portion of the input string to start parsing next",1,null],[12,"offset","","How far into the original string we are",1,null],[4,"Status","","An analog to `Result`, specialized for parsing.",null,null],[13,"Success","","",2,null],[13,"Failure","","",2,null],[6,"Identifier","","Matches a literal string to a specific type, usually an enum.",null,null],[8,"Point","","A location in the parsed data",null,null],[10,"zero","","The initial point",3,{"inputs":[],"output":{"name":"self"}}],[8,"Recoverable","","Indicate if an error should terminate all parsing.",null,null],[10,"recoverable","","",4,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"success","","",0,{"inputs":[{"name":"p"},{"name":"t"}],"output":{"name":"progress"}}],[11,"failure","","",0,{"inputs":[{"name":"p"},{"name":"e"}],"output":{"name":"progress"}}],[11,"map","","Convert the success value, if there is one.",0,null],[11,"map_err","","Convert the failure value, if there is one.",0,null],[11,"optional","","Returns the value on success, or rewinds the point and returns\n`None` on failure.",0,null],[11,"fmt","","",5,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"new","","",5,{"inputs":[],"output":{"name":"parsemaster"}}],[11,"optional","","Returns the value on success, or rewinds the point and returns\n`None` on a recoverable failure. Non-recoverable failures are\npropagated.",5,null],[11,"alternate","","Run sub-parsers in order until one succeeds.",5,null],[11,"zero_or_more","","Runs the parser until it fails.",5,null],[11,"finish","","When parsing is complete, provide the final result and gain\naccess to all failures. Will be recycled and may be used for\nfurther parsing.",5,null],[11,"one","","Run one alternative parser.",6,null],[11,"finish","","Complete the alternatives, returning the first successful branch.",6,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"zero","","",1,{"inputs":[],"output":{"name":"stringpoint"}}],[11,"new","","",1,{"inputs":[{"name":"str"}],"output":{"name":"stringpoint"}}],[11,"is_empty","","",1,null],[11,"to","","Slices the string.",1,null],[11,"consume_to","","Advances the point by the number of bytes. If the value is\n`None`, then no value was able to be consumed, and the result\nis a failure.",1,null],[11,"consume_literal","","Advances the point if it starts with the literal.",1,null],[11,"consume_identifier","","Iterates through the identifiers and advances the point on the\nfirst matching identifier.",1,null],[14,"try_parse","","An analog to `try!`, but for `Progress`",null,null]],"paths":[[3,"Progress"],[3,"StringPoint"],[4,"Status"],[8,"Point"],[8,"Recoverable"],[3,"ParseMaster"],[3,"Alternate"]]};
searchIndex["typed_arena"] = {"doc":"The arena, a fast but limited type of allocator.","items":[[3,"Arena","typed_arena","",null,null],[11,"new","","",0,{"inputs":[],"output":{"name":"arena"}}],[11,"with_capacity","","",0,{"inputs":[{"name":"usize"}],"output":{"name":"arena"}}],[11,"alloc","","Allocates a value in the arena, and returns a mutable reference\nto that value.",0,null],[11,"alloc_extend","","Uses the contents of an iterator to allocate values in the arena.\nReturns a mutable slice that contains these values.",0,null],[11,"alloc_uninitialized","","Allocates space for a given number of values, but doesn&#39;t initialize it.",0,null],[11,"uninitialized_array","","Returns unused space.",0,null],[11,"into_vec","","",0,null]],"paths":[[3,"Arena"]]};
initSearch(searchIndex);
